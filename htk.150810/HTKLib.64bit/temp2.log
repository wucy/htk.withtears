HAdapt.c:   mat = (DMatrix *)New(&gstack,(S+1)*sizeof(DMatrix));
HAdapt.c:   smat = (DMatrix *)New(&gstack,(S+1)*sizeof(DMatrix));
HAdapt.c:   svec = (DVector *)New(&gstack,(S+1)*sizeof(DVector));
HAdapt.c:      mat[s] = CreateDMatrix(&gstack,vsize,vsize);
HAdapt.c:      smat[s] = CreateDMatrix(&gstack,vsize,vsize);
HAdapt.c:      svec[s] = CreateDVector(&gstack,vsize);
HAdapt.c:   Dispose(&gstack,mat);
HAdapt.c:      lclasses = CreateIntVec(&gstack,IntVecSize(classes));
HAdapt.c:      FreeIntVec(&gstack,lclasses);
HAdapt.c:   classes = CreateIntVec(&gstack,rtree->bclass->numClasses);
HAdapt.c:   FreeIntVec(&gstack,classes);
HAdapt.c:	ac = (AccCache **)New(&gstack,sizeof(AccCache *)*(nxfcomb+1));
HAdapt.c:      if (ac != NULL) Dispose(&gstack,ac);
HAdapt.c:      oc = (ObsCache **)New(&gstack,sizeof(ObsCache *)*(nxfcomb+1));
HAdapt.c:    if (oc != NULL) Dispose(&gstack,oc);
HAdapt.c:   vec = CreateVector(&gstack,size);
HAdapt.c:   FreeVector(&gstack,vec);
HAdapt.c:   mat = CreateMatrix(&gstack,size,size);
HAdapt.c:   FreeMatrix(&gstack,mat);
HAdapt.c:  Vector cov = CreateVector(&gstack,size);    
HAdapt.c:  FreeVector(&gstack, cov);
HAdapt.c:         tvec = CreateDVector(&gstack,dim);
HAdapt.c:         G = CreateDMatrix(&gstack,dim,dim);
HAdapt.c:         FreeDVector(&gstack,tvec);
HAdapt.c:         invG = CreateDMatrix(&gstack,dim,dim);
HAdapt.c:         u = CreateDMatrix(&gstack, dim, dim);
HAdapt.c:         v = CreateDMatrix(&gstack, dim, dim);
HAdapt.c:         w = CreateDVector(&gstack, dim);
HAdapt.c:         FreeDMatrix(&gstack,invG);
HAdapt.c:  tvec = CreateDVector(&gstack,dim);
HAdapt.c:  tvec = CreateDVector(&gstack,size);
HAdapt.c:  tmat = CreateDMatrix(&gstack,size,size);
HAdapt.c:  FreeDVector(&gstack,tvec);
HAdapt.c:  cofact = CreateDVector(&gstack,1);
HAdapt.c:  lG = CreateDMatrix(&gstack,ldim,ldim);
HAdapt.c:  invG = CreateDMatrix(&gstack,ldim,ldim);
HAdapt.c:  u = CreateDMatrix(&gstack, ldim, ldim);
HAdapt.c:  v = CreateDMatrix(&gstack, ldim, ldim);
HAdapt.c:  w = CreateDVector(&gstack, ldim);
HAdapt.c:  tW = CreateDVector(&gstack, ldim);
HAdapt.c:  tvec = CreateDVector(&gstack, ldim);
HAdapt.c:  lK = CreateDVector(&gstack, ldim);
HAdapt.c:  iW = CreateDVector(&gstack, ldim);
HAdapt.c:  FreeDVector(&gstack,cofact);
HAdapt.c:  iniA = CreateDVector(&gstack, xf->vecSize);
HAdapt.c:     bias = CreateDVector(&gstack,xf->vecSize);
HAdapt.c:  InvG = (DMatrix *)New(&gstack,sizeof(DMatrix)*(accs->dim+1)); 
HAdapt.c:    cofact = CreateDVector(&gstack,bsize);
HAdapt.c:    u = CreateDMatrix(&gstack, dim, dim);
HAdapt.c:    v = CreateDMatrix(&gstack, dim, dim);
HAdapt.c:    w = CreateDVector(&gstack, dim);
HAdapt.c:    A = CreateDMatrix(&gstack, bsize,bsize);
HAdapt.c:    W = CreateDVector(&gstack,dim);
HAdapt.c:    iniW = CreateDVector(&gstack,dim);
HAdapt.c:    tvec = CreateDVector(&gstack,dim);
HAdapt.c:      InvG[cnti] = CreateDMatrix(&gstack,dim,dim);
HAdapt.c:    FreeDVector(&gstack,cofact);
HAdapt.c:  FreeDVector(&gstack, iniA);
HAdapt.c:   withinCov = CreateDVector(&gstack,size);
HAdapt.c:   fisherRatio = CreateDVector(&gstack,size);
HAdapt.c:   FreeDVector(&gstack,withinCov);
HAdapt.c:   tcov = CreateVector(&gstack,size);
HAdapt.c:   FreeVector(&gstack,tcov);
HAdapt.c:   mat = CreateMatrix(&gstack,size,size);
HAdapt.c:   if (strmProj) vec = CreateVector(&gstack,size);
HAdapt.c:      tcov = CreateVector(&gstack,size);
HAdapt.c:   FreeMatrix(&gstack,mat);
HAdapt.c:   vec = CreateVector(&gstack,size);
HAdapt.c:      tvec = CreateVector(&gstack,size);
HAdapt.c:   FreeVector(&gstack,vec);
HAdapt.c:               mat = CreateDMatrix(&gstack,size,size);
HAdapt.c:               tmat = CreateDMatrix(&gstack,size,size);
HAdapt.c:               tvec = CreateDVector(&gstack,size);
HAdapt.c:   FreeDMatrix(&gstack,mat);
HAdapt.c:      mat = CreateMatrix(&gstack,size,size);
HAdapt.c:      FreeMatrix (&gstack, mat);
HAdapt.c:   InvG = (DMatrix *)New(&gstack,sizeof(DMatrix)*(accs->dim+1)); 
HAdapt.c:     cofact = CreateDVector(&gstack,bsize);
HAdapt.c:     u = CreateDMatrix(&gstack, dim, dim);
HAdapt.c:     v = CreateDMatrix(&gstack, dim, dim);
HAdapt.c:     w = CreateDVector(&gstack, dim);
HAdapt.c:     A = CreateDMatrix(&gstack,bsize,bsize);
HAdapt.c:           InvG[cnti] = CreateDMatrix(&gstack,dim,dim);
HAdapt.c:           InvG[cnti] = CreateDMatrix(&gstack,dim,dim);
HAdapt.c:     W = CreateDVector(&gstack,dim);
HAdapt.c:     iniW = CreateDVector(&gstack,dim);
HAdapt.c:     FreeDVector(&gstack, cofact);
HAdapt.c:   Dispose(&gstack,InvG);
HAdapt.c:   streams = CreateIntVec(&gstack,hset->swidth[0]);
HAdapt.c:   totCov = CreateTriMat(&gstack,size);
HAdapt.c:   totMean = CreateVector(&gstack,size);
HAdapt.c:   FreeIntVec(&gstack,streams);
HAdapt.c:   InvG = (DMatrix *)New(&gstack,sizeof(DMatrix)*(accs->dim+1)); 
HAdapt.c:     cofact = CreateDVector(&gstack,bsize);
HAdapt.c:     u = CreateDMatrix(&gstack, dim, dim);
HAdapt.c:     v = CreateDMatrix(&gstack, dim, dim);
HAdapt.c:     w = CreateDVector(&gstack, dim);
HAdapt.c:     A = CreateDMatrix(&gstack,bsize,bsize);
HAdapt.c:     W = CreateDVector(&gstack,dim);
HAdapt.c:     iniW = CreateDVector(&gstack,dim);
HAdapt.c:        InvG[cnti] = CreateDMatrix(&gstack,dim,dim);
HAdapt.c:     FreeDVector(&gstack, cofact);
HAdapt.c:   Dispose(&gstack,InvG);
HAdapt.c:      accs = CreateAccStruct(&gstack,xform,xform->hset->vecSize,GetBlockSize(xform,class));
HAdapt.c:      accs = CreateAccStruct(&gstack,xform,node->vsize,GetBlockSize(xform,class));
HAdapt.c:   Dispose(&gstack,accs);
HAdapt.c:  classes = CreateIntVec(&gstack,bclass->numClasses);
HAdapt.c:        accs = CreateAccStruct(&gstack,xform,xform->hset->vecSize,GetBlockSize(xform,b));
HAdapt.c:        accs = CreateAccStruct(&gstack,xform,GetVecSizeClass(bclass,b), GetBlockSize(xform,b));
HAdapt.c:    Dispose(&gstack,accs);
HAdapt.c:   mat = CreateMatrix(&gstack,NumRows(m1),NumCols(m2));
HAdapt.c:   FreeMatrix(&gstack,mat);
HAdapt.c:   bres = CreateVector(&gstack,xf->vecSize);
HAdapt.c:         imat = CreateMatrix(&gstack,bsize,bsize);
HAdapt.c:         res = CreateMatrix(&gstack,bsize,bsize);
HAdapt.c:   FreeVector(&gstack,bres);
HAdapt.c:	vec = CreateVector(&gstack,VectorSize(svec));
HAdapt.c:	FreeVector(&gstack,vec); 
HArc.c:printf("IN SortArcs, gstack->totUsed = %d\n", gstack.totUsed);
HArc.c:   HArc   **arclist = New( &gstack , aInfo->nArcs * sizeof(HArc*) );
HArc.c:printf("\tSortArcs: New in gstack, gstack.totUsed = %d\n", gstack.totUsed);
HArc.c:printf("\tgstack SortArcs, gstack.totUsed = %d\n", gstack.totUsed);
HArc.c:   Dispose( &gstack , arclist );
HArc.c:printf("\tOUT SortArcs, gstack.totUsed = %d\n", gstack.totUsed);
HDict.c:   wlist = (Word *)New(&gstack,sizeof(Word)*(nw+1));
HFB.c:      md = CreateIntVec(&gstack,hmm->numStates);
HFB.c:      so = CreateIntVec(&gstack,hmm->numStates);
HFB.c:      FreeIntVec(&gstack,so); FreeIntVec(&gstack,md);
HFB.c:   maxP = CreateDVector(&gstack, Q);   /* for calculating beam width */
HFB.c:   comp_prob = CreateVector(&gstack,fbInfo->maxM);
HFB.c:      ovec = CreateVector(&gstack,hset->vecSize);
HFB.c:   FreeVector(&gstack,comp_prob);
HFB.c:   utt->ot = MakeObservation(&gstack,al_hset->swidth,info.tgtPK,
HFB.c:       utt->ot2 = MakeObservation(&gstack,al_hset->swidth,info2.tgtPK,
HLat.c:         llfExt = CopyString(&gstack,buf);
HLM.c:   neTab=(NEntry **) New(&gstack,sizeof(NEntry*)*nglm->counts[0]);
HLM.c:   Dispose(&gstack,neTab);
HMath.c:   l = CreateDMatrix(&gstack,n,n);
HMath.c:   x = CreateDVector(&gstack,n);
HMath.c:   y = CreateDVector(&gstack,n);
HMath.c:   FreeDMatrix(&gstack,l);    /* cut back stack to entry state */
HMath.c:   l = CreateDMatrix(&gstack,n,n);
HMath.c:   FreeDMatrix(&gstack,l);
HMath.c:      tempMatrix_A_mult_C = CreateMatrix(&gstack,NumRows(A),NumCols(C));
HMath.c:      FreeMatrix(&gstack,tempMatrix_A_mult_C);
HMath.c:   tmp1 = CreateDVector(&gstack, n);
HMath.c:   tmp2 = CreateDVector(&gstack, n);
HMath.c:   tmp3 = CreateDVector(&gstack, n);
HMath.c:   FreeDVector(&gstack, tmp1);
HMath.c:   A_tmp = CreateDMatrix(&gstack, n, n);
HMath.c:   f = CreateDVector(&gstack,n-1);
HMath.c:   FreeDMatrix(&gstack, A_tmp);
HMath.c:   tmp1 = CreateDMatrix(&gstack,m, n);
HMath.c:   FreeDMatrix(&gstack,tmp1);
HMath.c:   vv = CreateVector(&gstack,n);
HMath.c:   FreeVector(&gstack,vv);
HMath.c:   a=CreateMatrix(&gstack,n,n);
HMath.c:   FreeMatrix(&gstack,a);
HMath.c:   vv = CreateDVector(&gstack,n);
HMath.c:   FreeDVector(&gstack,vv);
HMath.c:   a=CreateDMatrix(&gstack,n,n);
HMath.c:   FreeDMatrix(&gstack,a);
HMath.c:   a=CreateMatrix(&gstack,n,n);
HMath.c:   FreeMatrix(&gstack,a);
HMath.c:   a=CreateDMatrix(&gstack,n,n);
HMath.c:   FreeDMatrix(&gstack,a);
HMath.c:   a=CreateDMatrix(&gstack,n,n);
HMath.c:   FreeDMatrix(&gstack,a);
HMath.c:   a=CreateDMatrix(&gstack,n,n);
HMath.c:   b=CreateDMatrix(&gstack,n,n);
HMath.c:   FreeDMatrix(&gstack,b);
HMath.c:   FreeDMatrix(&gstack,a);
HMath.c:    temp = (NFloat *) New(&gstack, sizeof(NFloat) * MAX(nrows, ncols) * MAX(nrows, ncols));
HMath.c:    slist = (SRank *) New(&gstack, ncols);
HMath.c:    Dispose(&gstack, temp);
HMath.c:    rv1 = (double *) New(&gstack, sizeof(double) * ncols);
HMath.c:   Dispose(&gstack, rv1);
HMath.c:    /*superb = CreateVector(&gstack, MIN(nrows, ncols) - 1);
HMath.c:    Dispose(&gstack, superb);*/
HMem.c:MemHeap gstack;   /* global MSTAK for general purpose use */
HMem.c:   CreateHeap(&gstack, "Global Stack",  MSTAK, 1, 0.0, 100000, ULONG_MAX ); /* #### should be max size_t */
HMem.c:   x->protectStk = (x==&gstack)?FALSE:protectStaks; 
HModel.c:    floatMat = CreateMatrix(&gstack, intVals[0], intVals[1]);
HModel.c:    FreeMatrix(&gstack, floatMat);
HModel.c:    floatVec = CreateVector(&gstack, intVal);
HModel.c:    FreeVector(&gstack, floatVec);
HModel.c:      mm=CreateMatrix(&gstack,nstates,nstates);
HModel.c:      FreeMatrix(&gstack,mm);
HModel.c:    floatVec = CreateVector(&gstack, srcVec->vecLen);
HModel.c:    FreeVector(&gstack, floatVec);
HModel.c:    floatMat = CreateMatrix(&gstack, srcMat->rowNum, srcMat->colNum);
HModel.c:    FreeMatrix(&gstack, floatMat);
HModel.c:                    dset.hmem = &gstack;
HModel.c:                    dhmm = (HLink) New(&gstack, sizeof(HMMDef));
HModel.c:                        Dispose(&gstack, dhmm);
HModel.c:                        Dispose(&gstack, dhmm);
HModel.c:                    Dispose(&gstack, dhmm);
HModel.c:   xmm = CreateVector(&gstack,vecSize);
HModel.c:   FreeVector(&gstack,xmm);
HModel.c:   xmm = CreateVector(&gstack,vecSize);
HModel.c:   trans_xmm = CreateVector(&gstack,vecSize);
HModel.c:   FreeVector(&gstack,xmm);
HNCache.c:    srcVals = (void *) New(&gstack, unitLen * n);
HNCache.c:printf("gstack A\n");
HNCache.c:    Dispose(&gstack, srcVals);
HNet.c:   order=(int *) New(&gstack, sizeof(int)*(lat->nn<lat->na ? lat->na+1 : lat->nn+1));
HNet.c:   rorder=(int *) New(&gstack, sizeof(int)*lat->nn);
HNet.c:printf("gstack B\n");
HNet.c:   Dispose(&gstack,order);
HNet.c:   newlat = NewLattice(&gstack,nNodes,nArcs);
HNet.c:printf("gstack C\n");
HNet.c:   Dispose(&gstack,newlat);
HNet.c:   temp=(int *) New(&gstack,sizeof(int)*hci->nci);temp--;
HNet.c:printf("gstack D\n");
HNet.c:   Dispose(&gstack,temp+1);
HNet.c:      pii=(PInstInfo *) New(&gstack,(thisWord->nprons+1)*(nAdd+1)*sizeof(PInstInfo));
HNet.c:printf("gstack E\n");
HNet.c:      Dispose(&gstack,++pii);
HParm.c:static MemHeap parmHeap;                /* HParm no longer uses gstack */
HParm.c:   vec = CreateVector(&gstack,size);
HParm.c:   FreeVector(&gstack,vec);
HParm.c:   odata = New(&gstack,nframes*sizeof(Vector));
HParm.c:      odata[i] = CreateVector(&gstack,fsize);
HParm.c:printf("gstack F\n");
HParm.c:   Dispose(&gstack,odata+1);
HParm.c:            tmp = CreateVector(&gstack,d);
HParm.c:            FreeVector(&gstack,tmp);
HParm.c:         tmp = CreateVector(&gstack,d);
HParm.c:         FreeVector(&gstack,tmp);
HParm.c:         appendVec = CreateVector(&gstack,cf->appendXFormSize);
HParm.c:         FreeVector(&gstack,appendVec);
HParm.c:   a = CreateVector(&gstack,d);  k = CreateVector(&gstack,d);
HParm.c:   FreeVector(&gstack,k); FreeVector(&gstack,a); 
HParm.c:   a = CreateVector(&gstack,d);  k = CreateVector(&gstack,d);
HParm.c:   FreeVector(&gstack,k); FreeVector(&gstack,a); 
HParm.c:   a = CreateVector(&gstack,d);  c = CreateVector(&gstack,dnew);
HParm.c:   FreeVector(&gstack,c); FreeVector(&gstack,a); 
HParm.c:   a = CreateVector(&gstack,d);  c = CreateVector(&gstack,d);
HParm.c:   FreeVector(&gstack,c); FreeVector(&gstack,a); 
HParm.c:   v = CreateVector(&gstack,d);
HParm.c:   FreeVector(&gstack,v); 
HParm.c:   v = CreateVector(&gstack,d);
HParm.c:   FreeVector(&gstack,v); 
HParm.c:   fbank = CreateVector(&gstack,d);  c = CreateVector(&gstack,dnew);
HParm.c:   FreeVector(&gstack,c); FreeVector(&gstack,fbank); 
HParm.c:   v=CreateVector(&gstack,n);
HParm.c:   eFr=CreateVector(&gstack,nFr);
HParm.c:   v=CreateVector(&gstack,cf->frSize);
HParm.c:   eFr=CreateVector(&gstack,nFr);
HParm.c:   v=CreateShortVec(&gstack,cf->frSize);
HParm.c:   teFr=CreateVector(&gstack,mFr);
HParm.c:   eFr=CreateVector(&gstack,nFr);
HParm.c:   eFr=CreateVector(&gstack,nFr);
HParm.c:   v=CreateVector(&gstack,size);
HParm.c:   s=CreateShortVec(&gstack,size);
HParm.c:   FreeShortVec(&gstack,s);
HParm.c:   FreeVector(&gstack,v);
HParm.c:      min = CreateVector(&gstack,nCols); ZeroVector(min); 
HParm.c:      max = CreateVector(&gstack,nCols); ZeroVector(max); 
HParm.c:      FreeVector(&gstack,max); FreeVector(&gstack,min);
HParm.c:         sp=(short *) New(&gstack,sizeof(short)*pb->nRows*cf->nCols);
HParm.c:printf("gstack G\n");
HParm.c:         Dispose(&gstack,sp);
HRec.c:   ans=(NBestEntry**) New(&gstack,sizeof(NBestEntry*)*N);ans--;
HRec.c:   order=(int*) New(&gstack, sizeof(int)*lat->nn);
HRec.c:   Dispose(&gstack,order);
HRec.c:         newNBE=(NBestEntry*) New(&gstack,sizeof(NBestEntry));
HRec.c:            newNBE=(NBestEntry*) New(&gstack,sizeof(NBestEntry));
HRec.c:   ans++;Dispose(&gstack,ans);
HSigP.c:   newA  = CreateVector(&gstack,order);
HSigP.c:   FreeVector(&gstack,newA);
HSigP.c:   r = CreateVector(&gstack,p);
HSigP.c:   thisA = (a!=NULL)?a:CreateVector(&gstack,p);
HSigP.c:   FreeVector(&gstack,r);
HSigP.c:   thisA = CreateVector(&gstack,p);
HSigP.c:   newA  = CreateVector(&gstack,p);
HSigP.c:   FreeVector(&gstack,thisA);
HSigP.c:   thisA = CreateVector(&gstack,p);
HSigP.c:   newA  = CreateVector(&gstack,p);
HSigP.c:   FreeVector(&gstack,thisA);
HTrain.c:   sum = CreateDVector(&gstack,size);
HTrain.c:   FreeDVector(&gstack,sum);
HTrain.c:      sqsum = CreateDVector(&gstack,size);
HTrain.c:      FreeDVector(&gstack,sqsum);
HTrain.c:      xsum = CreateDMatrix(&gstack,size,size);
HTrain.c:      FreeDMatrix(&gstack,xsum);
HTrain.c:      sqsum = CreateDVector(&gstack,vSize);
HTrain.c:      FreeDVector(&gstack,sqsum);
HTrain.c:      xsum = CreateDMatrix(&gstack,vSize,vSize);
HTrain.c:      c = CreateMatrix(&gstack,vSize,vSize);
HTrain.c:      FreeDMatrix(&gstack,xsum);
HTrain.c:   cmap = CreateShortVec(&gstack,nItems);
HTrain.c:   vTmp = CreateVector(&gstack,vSize);
HTrain.c:   FreeShortVec(&gstack,cmap);
HTrain.c:   FreeShortVec(&gstack,cmap);
HTrain.c:   cTemp = CreateVector(&gstack,numMixtures);
HTrain.c:   FreeVector(&gstack,cTemp);
HTrain.c:   vTemp = CreateVector(&gstack,vSize);
HTrain.c:   FreeVector(&gstack,vTemp);
HTrain.c:      vTemp = CreateVector(&gstack, vSize);
HTrain.c:      FreeVector(&gstack, vTemp);
HTrain.c:      mTemp = CreateTriMat(&gstack,vSize);
HTrain.c:      FreeTriMat(&gstack,mTemp);
HTrain.c:   tTemp = CreateMatrix(&gstack,numStates,numStates);
HTrain.c:   nTemp = CreateVector(&gstack,numStates);
HTrain.c:   FreeMatrix(&gstack,tTemp);
HVQ.c:      vx = CreateVector(&gstack,size);
HVQ.c:      FreeVector(&gstack,vx);
HWave.c:      tmp = (short *)New(&gstack,w->nSamples*2);
HWave.c:      Dispose(&gstack,tmp);
